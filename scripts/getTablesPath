getTablesPath_()
{
  # path to the current user's home
  export QA_TABLES

  if [ ${QA_TABLES} ] ; then
    # if it is a new path, then adjust the config file
    . $QA_SRC/scripts/parseConfigFile QA_TABLES=${QA_TABLES}
    return 0
  fi

  if . $QA_SRC/scripts/parseConfigFile QA_TABLES ; then
     return 0
  fi

  local p_tables

  if try_other_sections ; then
     QA_TABLES=$p_tables
  else
     p_tables=${HOME}/.qa-dkrz/QA_TABLES

     local i
     while : ; do
        echo -e -n "\nPlease, specify a new spot for project tables "
        read -p "[default: ${p_tables}], <cancel>: " QA_TABLES

        if mkdir -p ${QA_TABLES} &> /dev/null ; then
           break
        fi

        echo "Could not mkdir ${QA_TABLES} (missing permission?)."
        echo "Note that you need permissions because external table will be downloaded."

        i=$(( i + 1 ))
        if [ ${i} = 3 ] ; then
          echo "Sorry, too many attempts. Exit"
          exit 41
        fi
     done
  fi

  if [ ${QA_TABLES} ] ; then
     . $QA_SRC/scripts/parseConfigFile QA_TABLES=${QA_TABLES}
  fi

  return 0
}

try_other_sections()
{
  # before asking for a QA-TABLE spot, the config.txt file is
  # investigated for possibilities

  # try QA_TABLES from other config file sections, if any.
  local i qts
  declare -a qts

  qts=( $( grep 'QA_TABLES[[:space:]]*=' $CONFIG_FILE ) )
  qts=( ${qts[*]#*=} )

  if [ ${#qts[*]} -eq 0 ] ; then
     return 1
  elif [ ${#qts[*]} -gt 1 ] ; then
     # compare to the first one
     for(( i=1 ;  i < ${#qts[*]} ; ++i )) ; do
        if [ "${qts[0]}" = "${qts[i]}" ] ; then
          qts[i]=
        fi
     done
     qts=( ${qts[*]} )
  fi

  local prompt_text ix
  echo -e "\nA path to project tables is required."

  if [ ${#qts[*]} -eq 1 ] ; then
     prompt_text="Do you want to use ${qts[0]}. <y>, <[no|new]>, <cancel>: "

     while : ; do
       read -p "${prompt_text}"  p_tables

<<<<<<< HEAD
       case ${p_tables:0:1} in
         ( n | '') return 1  ;;
           c)      exit 41   ;;
           y)      ix=0      ;;
           *)      continue  ;;
       esac

       echo ''  # just for a newline
       break
     done
=======
  test ${DEBUG} && set +x

  echo -e "\nPlease, specify variable QA_TABLES [default: ${dpath}], " # > ${TTY}
  read -p "the spot for external tables and programs: " QA_TABLES # 2> ${TTY}

  test ${DEBUG} && set -x

  test ! ${QA_TABLES} && QA_TABLES=${dpath}

  local i
  for i in 1 2 3 ; do
     if [ ${i} -eq 3 ] ; then
       echo "Could not mkdir QA_TABLES=${QA_TABLES}."
       exit 41
     fi

     if mkdir -p ${QA_TABLES} &> /dev/null ; then
        . $QA_SRC/scripts/parseConfigFile QA_TABLES=${QA_TABLES}
        break
     fi

     echo "Could not mkdir QA_TABLES=${QA_TABLES} (missing permission?)."
     dpath=${HOME}/.qa-dkrz
     read -p "Do you want to try ${dpath} ? " QA_TABLES # 2> ${TTY}
  done

  if [ -d $QA_TABLES ] ; then
     if [ ! -w $QA_TABLES ] ; then
       echo "directory $QA_TABLES without write permissions,"
       exit 41
     fi
>>>>>>> 21461e0291161b7377167fa380fc7bce27845111
  else

     while : ; do
       prompt_text=

       for (( i=0 ; i < ${#qts[*]} ; ++i )) ; do
         echo "Found for index ${i}: ${qts[i]}"
       done

       prompt_text="<enter index for selection:>, <[new|no]>, <cancel>: "
       read -p "${prompt_text}" ix

       if [ ${ix} -ge ${#qts[*]} ] ; then
          echo "Sorry, input exceeds available number."
          continue
       fi

       case ${ix:0:1} in
         ( 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7) break  ;;
         ( n |  '') return 1  ;;
         *)         continue ;;
       esac

       echo ''  # just for a newline
       break
     done

  fi

  p_tables="${qts[ix]}"

  return 0
}


# main

getTablesPath_ $1

test ${isDebug} && echo "return: getTablesPath" > /dev/null

return
